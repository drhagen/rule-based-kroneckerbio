/**
 * (c) 2012 David R Hagen & Bruce Tidor
 * This work is released under the MIT license.
 */
package kroneckerbio.model

import kroneckerbio.utilities.Inquirable._
import kroneckerbio.utilities.ErrorBuffer.{ConcreteError, ErrorBuffer}

trait Pattern {
  def Main: Graph
  def Disjoint: Inquirable[Graph]
  def Compartment: CompartmentSite

  // Connections between disjoint and main are no longer allowed
  // Ensure that all edges appears exactly twice and that edges only connect monomers within the same graph
  // or between the main graph and a disjoint graph
  /*def validate_pattern_edges() = {
    val errors = new ErrorBuffer()

    // All bound edges in main graph
    val main_edges = this.Main.Monomers.flatMap(_.Sites).flatMap(_.Edge.list).filter(_ != UnboundEdge())

    // List of bound edges in each disjoint graph
    val disjoint_edges = this.Disjoint.leaves.map(_.Monomers.flatMap(_.Sites).flatMap(_.Edge.list).filter(_ != UnboundEdge()))

    // Ensure that every edge appears exactly twice
    val wrong_edge_counts = main_edges.groupBy(identity).mapValues(_.size).filter(_._2 != 2)

    if (wrong_edge_counts.size == 0) {
      // All are equal to 2, proceed with further validation
      // Edges in main cannot be wrong because they can bind to anything, but edges in disjoint
      // must bind to the main or bind internally to the same disjoint graph
      val disjoint_edges_without_main = disjoint_edges.map(_.diff(main_edges))

      val remaining_edge_counts = disjoint_edges_without_main.map(_.groupBy(identity).mapValues(_.size))

      val wrong_edges = remaining_edge_counts.flatten.filter(_._2 != 2).map(_._1) // Somehow a set

      // Add any errors that should be generated by un
      errors ++ (
        for (wrong_edge <- wrong_edges) yield {
          new ConcreteError("Edge #" + wrong_edge + " spans disjoint graphs")
        }
        )
    }
    else {
      // Some were not equal to 2, generate errors and return
      errors ++ (
        for (edge_count <- wrong_edge_counts) yield {
          new ConcreteError("Edge #" + edge_count._1 + " appears " + edge_count._2 + " times")
        }
        )
    }

    // Return
    errors
  }*/

  def MainBoundEdgeIndexes: Seq[Int] = this.Main.BoundEdgeIndexes

  def DisjointBoundEdgeIndexes: Seq[Int] = this.Disjoint.leaves.flatMap(_.BoundEdgeIndexes)

  def BoundEdgeIndexes: Seq[Int] = MainBoundEdgeIndexes ++ DisjointBoundEdgeIndexes
}

trait Graph {
  def Monomers: Seq[Monomer]

  def BoundEdgeIndexes: Seq[Int] = Monomers.flatMap(_.BoundEdgeIndexes).distinct

  def validate_graph_edges() = {
    // All bound edges in graph
    val bound_edges = Monomers.flatMap(_.BoundEdgeIndexes)

    // Ensure that every edge appears exactly twice
    val wrong_edge_counts = bound_edges.groupBy(identity).mapValues(_.size).filter(_._2 != 2)

    // Generate errors for those that were not equal
    val errors = {
      for (edge_count <- wrong_edge_counts) yield {
        new ConcreteError("Edge #" + edge_count._1 + " appears " + edge_count._2 + " times")
      }
    }

    // Return
    errors
  }
}

trait Monomer {
  val Name: String
  def Sites: Seq[Site]
  def Compartment: CompartmentSite

  def AllCompartmentNames = Compartment.AllCompartmentNames

  // Not distinct
  def BoundEdgeIndexes = Sites.flatMap(_.AllBoundEdgeIndexes)
}

trait Site {
  val Name: String
  def State: StateSite
  def Edge: EdgeSite

  def AllBoundEdgeIndexes: Seq[Int] = Edge match {
    case BoundSiteEdge(BoundEdge(edge)) => Seq(edge)
    case _                              => Nil
  }

}
